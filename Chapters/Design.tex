\chapter{Specification \& Design}
\label{sec:design}

Mirroring the convention for modern compilers, the compiler will be implemented with distinct phases
for each major transformation step outlined in the requirements. This is illustrated in
Figure~\ref{fig:project-compiler-spec}.

\begin{figure}
      \centering
      \includestandalone[width=\textwidth]{Graphics/project-compiler-spec}
      \caption{A diagram of each phase of the proposed compiler.}
      \label{fig:project-compiler-spec}
\end{figure}

\section{Technologies}

The language selected for this compiler is \emph{Scala}, a JVM-based functional programming
language. This choice of language was primarily motivated by the concise and expressive syntax Scala
provides, such as operator overloading and extensive support for pattern matching. However, the
choice of language is not a major factor in dictating the design of the compiler, as many of the
implementation and design decisions could easily be ported to other languages.

The \emph{ScalaTest} library will be used for testing, ensuring that the compiler is semantically
correct, as well as for identifying any regressions in the compiler's behaviour.

The LLVM static compiler \texttt{llc} will be used to generate the object file required for linking
the final executable with \texttt{gcc}. Using \texttt{llc} provides access to the same compiler
optimisations as seen in \texttt{clang} (i.e., \texttt{-O1, -02, -03}), negating the need for
implementing certain optimisations within the compiler itself.

\section{Compiler Phases}

\subsection{Parser}

This phase is responsible for transforming the stream of characters from a source file into an AST.
The implementation will be carried out using \emph{FastParse}, a parser combinator library for
Scala. This decision was motivated by the library's parsing performance in comparison to other
parser libraries, extensive tooling for debugging and testing, in addition to its judicious use of
Scala's language features. This results in a syntax for defining parsers that is modular and simple
to reason about.

The trade-off when using FastParse is that it operates directly with the stream of characters,
rather than a stream of tokens (known as \emph{scannerless parsing}). This means that the lexical
analysis phase will be omitted, with the parser responsible for identifying tokens.

The context-free grammar used by the parser must be unambiguous, and
(particularly for arithmetic and boolean expressions) correctly reflect the precedence and
associativity of operators.


(Language BNF to be included here (or in appendix? implementation?))

\subsection{IRGen}

The resulting AST from the parser will be transformed into an intermediate representation (IR),
based on ANF. ANF-form was selected over CPS-form due to its ease in converting to the eventual LLVM
IR.

Within this phase, enumerated types are also de-sugared into integer constants, and pattern matching
is de-sugared into a series of \texttt{if} statements. (To be extended if time permits.)

(Again, language of IR to be included here (or in appendix? implementation?))


\subsection{ClosureConv}

Supporting higher-order functions requires the introduction of closures, due to the need to capture
free variables (variables that are not defined within the function) present inside a function. This
phase is done in multiple steps:

\begin{enumerate}
      \item \textbf{Identify free variables} - Free variables are identified by
            analysing variables used but not declared within a function.

      \item \textbf{Closure Conversion} - An additional \emph{environment} parameter is added to the
            function, containing the free variable values. Any reference to the free variables
            within the function body are then modified to reference the captured variables in the
            environment.

            Any returns of the function are re-written to return a tuple containing a pointer to the
            function, and the environment. Calls to the function are re-written to extract the
            function pointer from the tuple, and pass the environment as an additional parameter.

      \item \textbf{Hoisting} - Functions are hoisted to the top-level global scope, removing any
            nested functions prior to code generation.
\end{enumerate}

\subsection{LLVMGen}

This final phase is responsible for traversing the ANF IR and generating the corresponding LLVM IR.
Any additional runtime functions required for supporting the language features are also generated
within this phase, such as functions to \texttt{print()}. It is imperative that the type information
from the source language is preserved up to this point, as the LLVM IR is strongly typed.

